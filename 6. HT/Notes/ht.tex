\section{Hash Tables}
\subsection{Introduction to Hash Tables}

A Hash Table (also known as a Hash Map) is a data structure used to store key-value pairs. It allows for efficient insertion, deletion, and lookup operations â€” ideally in constant time, O(1).

Think of a library where you have an index card that tells you exactly where a book is located. Instead of searching all shelves, you use the index (the key) to go directly to the shelf and retrieve the book (the value).
This is similar to how a hash table retrieves data.


\subsection{Core Components}
\begin{itemize}
    \item \textbf{\textit{Hash Function}}: A hash function takes a key (e.g., a string) and transforms it into a numeric address (an index) where the value is stored in an underlying list.
    \item \textbf{\textit{Data Map (Underlying Array)}}: An array (list) where each index is an addressable location for storing one or more key-value pairs.
    \item \textbf{\textit{Node / Bucket}}: Each index may hold None (empty)
    or  A single key-value pair or a list of key-value pairs (in case of collisions)
\end{itemize}

\subsection{Common Hash Table Methods}
\begin{itemize}
    \item \texttt{set(key, value)}: Stores the value under the key.
    \item \texttt{get(key)}: Retrieves the value associated with the key.
    \item \texttt{keys()}: Returns all the keys.
\end{itemize}

\subsection{Collisions}
Two keys may hash to the same index. This is called a \textbf{collision}.

\textbf{How to handle collisions?}
\begin{itemize}
    \item \textbf{Chaining:} Use a linked list at that index to store multiple key-value pairs.
    \item \textbf{Open Addressing:} Find another empty index linearly or with some formula.
\end{itemize}

\subsection{Big O Time Complexity}
\begin{center}
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Operation} & \textbf{Best Case} & \textbf{Average Case} & \textbf{Worst Case} \\
        \hline
        \texttt{set} / \texttt{get} / \texttt{delete} & $O(1)$ & $O(1)$ & $O(n)$ \\
        \hline
        \texttt{keys()} & $O(n)$ & $O(n)$ & $O(n)$ \\
        \hline
    \end{tabular}
\end{center}

\textbf{Why Worst Case is $O(n)$?}
\begin{itemize}
    \item If all keys hash to the same index $\Rightarrow$ large linked list $\Rightarrow$ linear time.
    \item With a good hash function and a large enough array, this is rare.
\end{itemize}

\subsection{Real-world Examples}
\begin{itemize}
    \item Phone book (name $\rightarrow$ number).
    \item Caching.
    \item Databases.
    \item DNS resolution (domain $\rightarrow$ IP).
\end{itemize}
